<!DOCTYPE html>
<meta charset="utf-8">

<!-- dzslides core
    __  __  __       .  __   ___  __
   |  \  / /__` |    | |  \ |__  /__`
   |__/ /_ .__/ |___ | |__/ |___ .__/ core :‚Ç¨

The default files are not supposed to be edited. Not that you can't.
-->
<script src="default/slide.js"></script>
<link rel="stylesheet" href="default/style.css">

<!-- Maybe a font from http://www.google.com/webfonts ? -->
<link href='http://fonts.googleapis.com/css?family=Oswald' rel='stylesheet'>
<!-- Your Style -->
<link rel="stylesheet" href="custom.css">

<title>Bash best and worst practices</title>

<section>
    <h1>Bash</h1>
    <h2>best and worst practices</h2>
    <footer>by Philipp Martis and Andreas Nordal</footer>
</section>

<section>
	<h1>Why care</h1>
	<p class="next">Common myths:</p>
	<ul>
	<li><i>LOL, shellscripts are old-school</i></li>
	<li><i>Leads to bugs</i></li>
	<li><i>I'm not writing them</i></li>
	</ul>
</section>

<section>
	<p>What <i>is</i> shellscripting anyway?</p>
	<code>&gt;¬†1+1
1+1: Command not found.
&gt;¬†calc '1+1'
2</code>
	<p class="next">Programs as building blocks<p>
	<p class="next">Shellscripting is a paradigm!</p>
	<footer><i>‚ÄúOld school‚Äù</i></footer>
</section>

<section>
	<p>Where shellscripts are found [1/2]</p>
	<ul>
	<li>Personal automation</li>
	<li>Your typical test script</li>
	<li>Build systems</li>
	<ul>
	<li>Makefiles</li>
	<li>Dockerfiles</li>
	<li>Openembedded</li>
	</ul>
	<li>Every script that runs over ssh</li>
	</ul>
	<ul>
	<footer><i>‚ÄúI'm not writing them‚Äù</i>¬†¬†¬†¬†¬†¬†</footer>
</section>

<section>
	<p>Where shellscripts are found [2/2]</p>
	<ul>
	<li>C/C++: <tt>system("")</tt></li>
	<li>Python: <tt>subprocess.call("", shell=True)</tt></li>
	</ul>
	<p class="next">So far, OK!</p>
	<p class="next">What about:</p>
	<ul class="next">
	<li>C++: <tt>std::string cmd("./script.py ") + filename; system(cmd);</tt></li>
	<li>Python: <tt>subprocess.call("./script.py " + filename, shell=True)</tt></li>
	</ul>
</section>

<section>
	<p>How <i>not</i> to generate shellscripts at runtime, often with improper quoting?</p>
	<ul>
	<li>A command is fundamentally an array (<tt>argv</tt>)</li>
	<li>Environment variables too.</li>
	</ul>
	<p class="next">‚Üí The command <i>line</i> is an illusion.</p>
	<p class="next">‚Üí If you are doing string processing, you are doing it wrong.</p>
</section>

<section>
	<p>From this:</p>
	<code>auto cmd = std::string("LANG=C.UTF-8 ./script.py ") + filename;
system(cmd);</code>
	<footer>How <i>not</i> to write a shellscript</footer>
</section>

<section>
	<p>To this:</p>
	<code>const char* cmd[] = {
    "./script.py",
    filename,
    NULL
};
const char* env[] = {
    "LANG=C.UTF-8",
    NULL
};
posix_spawn(‚Ä¶, cmd[0], ‚Ä¶, ‚Ä¶, cmd, env)</code>
	<footer>How <i>not</i> to write a shellscript</footer>
</section>

<section>
	<p class="next">#1 bug antidote ‚Üí</p>
	<footer><i>‚ÄúLeads to bugs‚Äù</i></footer>
</section>




<section>
	<p>The driver's license of Bash scripting:</p>
	<h1><b>"</b>Quoting<b>"</b></h1>
</section>

<section>
	<p>Must be quoted [1/2]:</p>
	<h1><b>"</b>$var<b>"</b></h1>
	<footer>Variable expansion</footer>
</section>

<section>
	<p>Must be quoted [2/2]:</p>
	<h1><b>"</b>$(cmd)<b>"</b></h1>
	<h1 class="next"><b>"</b>`cmd`<b>"</b></h1>
	<footer>Command substitution</footer>
</section>

<section>
	<h1>Why quote?</h1>
	<p class="evil next">üî• Evil implicit behavior üî•</p>
	<ol>
	<li>Word splitting</li>
	<li>Filename expansion</li>
	</ol>
</section>

<section>
	<p>What happens here?</p>
	<code>file="Aqua - Doctor Jones.mp3"
rm $file</code>
	<code class="next">‚Üí <span class="bg">rm</span> <span class="bg">Aqua</span> <span class="bg">-</span> <span class="bg">Doctor</span> <span class="bg">Jones.mp3</span></code>
	<footer>Word splitting</footer>
</section>

<section>
	<p>What happens here?</p>
	<code>dir="Sagittarius_A*"
rm -rf $dir</code>
	<code class="next">‚Üí <span class="bg">rm</span> <span class="bg">-rf</span> <span class="bg">Sagittarius_AB</span> <span class="bg">Sagittarius_And_Other_Dwarf_Galaxies</span> <span class="bg">Sagittarius_A*</span></code>
	<footer>Filename expansion</footer>
</section>

<section>
	<h2>Quiz</h2>
	<code>file="; rm -rf /"
cat $file</code>
	<code class="next">‚Üí <span class="bg">cat</span> <span class="bg">;</span> <span class="bg">rm</span> <span class="bg">-rf</span> <span class="bg">/</span></code>
	<p class="next"><i>Not</i> a crazy macro language.</p>
	<footer>Just word splitting &amp; filename expansion</footer>
</section>

<section>
	<p>That's it! The driver's license to Bash.</p>
	<p>How to drive safely?</p>
	<h1>Demo</h1>
	<footer>shellcheck &amp; shellharden</footer>
</section>



<section>
	<h1>Good practices</h1>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Arrays</h3>
	<code>files=(
    script.py
    "Aqua - Doctor Jones.mp3"
    *.h
)
for f in "${files[@]}"; do
    ‚Ä¶
done</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Input and output</h3>
	<ul>
		<li class="next"><inline-code>&></inline-code>: Redirect stdout and stderr at once
	</ul>
	<br>
	<ul>
		<li class="next"><inline-code><<-'EOF'</inline-code>: Redirect stdin to yield
			the upcoming lines, until <inline-code>EOF</inline-code>
		<ul>
			<li class="next">... ignoring leading tabs (<inline-code>-</inline-code>)
			<li class="next">... literally (<inline-code>''</inline-code>)
		</ul>
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Input and output</h3>
	<ul>
		<li class="next"><inline-code><<< asdf</inline-code>: Redirect stdin to yield
			<inline-code>asdf</inline-code>
	</ul>
	<br>
	<ul>
		<li class="next"><inline-code><(git show)</inline-code>: Usable like a file
			containing the output of <inline-code>git show</inline-code>
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Parameter expansion</h3>
	<ul>
		<li><inline-code>${s%%/*}</inline-code>: <inline-code>s</inline-code>,
			without trailing <inline-code>/*</inline-code>
		<li><inline-code>${s#*/}</inline-code>: <inline-code>s</inline-code>,
			without shortest leading <inline-code>*/</inline-code>
		<li><inline-code>${s/a/b}</inline-code>: <inline-code>s</inline-code>,
			replacing first <inline-code>a</inline-code> with <inline-code>b</inline-code>
		<li><inline-code>${s//a/b}</inline-code>: <inline-code>s</inline-code>,
			replacing every <inline-code>a</inline-code> with <inline-code>b</inline-code>
		<li><inline-code>${!s}</inline-code>: Content of variable named <inline-code>"$s"</inline-code>
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3><inline-code>shopt -s</inline-code></h3>
	<ul>
		<li><inline-code>dotglob</inline-code>: Include hidden files when globbing
		<li><inline-code>nullglob</inline-code>: Expand unmatching globs to empty array
		<li><inline-code>globstar</inline-code>: Expand double-stars (<tt>**</tt>) recursively
		<li><inline-code>nocasematch</inline-code>: Ignore case
			(<b>not in</b> <inline-code>test</inline-code>/<inline-code>[</inline-code>!)
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3><inline-code>set</inline-code></h3>
	<ul>
		<li><inline-code>-x</inline-code>: Echo executed commands
		<li><inline-code>-e</inline-code>: Exit on errors (covered later)
		<li><inline-code>-u</inline-code>: Treat unset variables as errors (and exit)
		<li><inline-code>-o pipefail</inline-code>: Pipe fails if <b>any</b> of its commands fail
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Grouping: <inline-code>{ }</inline-code></h3>
	<code>cleanup || { essential_cleanup; exit 1; }</code>
	<code class="next">{ echo "[configuration]"; make_config; } > file.conf</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Subshells: <inline-code>( )</inline-code></h3>
	<medium>Changes don't affect parent shell</medium>
	<code class="next">( set -x; cmd lots of parameters )</code>
	<code class="next">if ( shopt -s nocasematch; [[ "$s" == "yes" ]] )</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Extended conditionals: <inline-code>[[¬†]]</inline-code></h3>
	<code class="next">shopt -s nocasematch; [[¬†"a" == "A" ]]</code>
	<code class="next">[[¬†"a" > "b" && (-f "file" || ! -f "file") ]]</code>
	<code class="next">[[ "a" =~ ^a(bc)*$ ]]</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Arithmetic conditionals: <inline-code>((¬†))</inline-code></h3>
	<code class="next">(( ! updated ))</code>
	<code class="next">(( (i += 2 ** $?) && (1 << 1 & 2) ))</code>
	<code class="next">for (( i = 0; i < n; ++i ))</code>
	<medium class="next">Be aware of recursive and history expansion!</medium>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Switch</h3>
	<code>for f in {src,include}/**; do
    case "$f" in
        *.h|*.cpp)
            ‚Ä¶
        ;;
        *)
            ‚Ä¶
        ;;
    esac
done</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Exit handler</h3>
	<code>set -e
tmpdir="$(mktemp -d)"
cleanup() {
    rm -rf "$tmpdir"
}
trap cleanup EXIT

cd "$tmpdir"
‚Ä¶
‚Ä¶
‚Ä¶
echo 'Great success!'</code>
</section>

<section>
	<h2>set -e</h2>
	<p>Some object fiercly to it</p>
	<br>
	<ul>
		<li>They have <a href=https://wiki.bash-hackers.org/scripting/obsolete>good</a>
	                      <a href=http://mywiki.wooledge.org/BashFAQ/105>points</a>
		<li>There are also good points for it:
	        <ul>
			<li class="next">Less code: more readable and less error-prone
			<li class="next">Catches most (programming) errors
		</ul>
	</ul>
</section>

<section>
	<h2>set -e</h2>
	<p>One example of the tribulations with <inline-code>set -e</inline-code></p>
	<code>f() {
    ( set -e; false; echo "D'oh!" )
}
f && false</code>
</section>

<section>
	<h2>set -e</h2>
	<small>
		The <inline-code>&&</inline-code> thwarts <inline-code>set -e</inline-code>,
		even inside a subshell inside a function!
	</small>
	<div class="next">
		<br>
		<p>Solution:</p>
		<code>f <green>& wait $!</green> && false</code>
	</div>
</section>





<section>
	<h1>Pitfalls</h1>
</section>


<section>
	<p>Positional args</p>
	<code>#!/bin/bash
echo "$1"</code>
	<code class="next">#!/bin/bash
echo "$10"</code>
	<code class="next">#!/bin/bash
echo "${10}"</code>
</section>

<section>
	<p>"$<b>{</b>10<b>}</b>" ‚Ä¶ But why?</p>
	<p class="next">There are 2 types of variable names:</p>
	<ol>
	<li class="next">An identifier: <code>[_a-zA-Z][_a-zA-Z0-9]*</code></li>
	<li class="next">A non-identifier single character: <code>[^_a-zA-Z]</code></li>
	</ol>
</section>

<section>
	<h2>Quiz</h2>
	<p>Where does the variable name end?</p>
	<code>einstein() { echo "$1ball"; }
einstein foot
</code>
	<code class="next">‚Üí <span class="bg">football</span>
‚Üí </code>
</section>

<section>
	<h2>Escaping and ` `</h2>
	<br>
	<br>
	<p class="next">Use <red>` `</red> only for simple things, if at all!</p>
</section>

<section>
	<h2>Quiz</h2>
	<p>How do you rewrite the following, using only one <inline-code>echo</inline-code>:</p>
	<code>echo "` echo "$(echo 'h\\i')" `"</code>
	<code class="next">echo 'h\i'  # or echo "h\\i"</code>
</section>

<section>
	<h2>Escaping and ` `</h2>
	<p>Being syntactically surrounded by <inline-code>` `</inline-code>
	   is enough to halve the number of <inline-code>\\</inline-code>s.
	</p>
	<p class="next"><inline-code>\n</inline-code> stays <inline-code>\n</inline-code>.
	</p>
</section>

<section>
	<h2>Variable shadowing</h2>
	<p>Consider</p>
	<code>greet() {
    name="$1"
    for s in –ø—Ä–∏–≤–µ—Ç Hello Hei; do
        echo "$s, $name!"
    done
}

read -p "What's your name? " s
greet "$s"
echo "I like the name $s!"
</code>
</section>

<section>
	<h2>Variable shadowing</h2>
	<p>Correct:</p>
	<code>greet() {
    <green>declare</green> name="$1" <green>s</green>
    for s in –ø—Ä–∏–≤–µ—Ç Hello Hei; do
        echo "$s, $name!"
    done
}

read -p "What's your name? " s
greet "$s"
echo "I like the name $s!"
</code>
</section>

<section>
	<h2>Variable shadowing</h2>
	<p>Good: üôÇ</p>
	<code>greet() {
    declare name="$1" <green>hello</green>
    for <green>hello</green> in –ø—Ä–∏–≤–µ—Ç Hello Hei; do
        echo "<green>$hello</green>, $name!"
    done
}

<green>declare name</green>
read -p "What's your name? " <green>name</green>
greet <green>"$name"</green>
echo "I like the name <green>$name</green>!"
</code>
</section>

<section>
	<h2>Variable visibility</h2>
	<p>Consider</p>
	<code>declare max="" line
get_values | while read -r line; do
    declare val="`parse "$line"`"
    if higher "$val" "$max"; then
        max="$val"
    fi
done
</code>
</section>

<section>
	<h2>Variable visibility</h2>
	<br>
	<p><inline-code>max</inline-code> isn't changed, since the whole loop
           runs in a subshell introduced by <inline-code>|</inline-code>.
	</p>
</section>

<section>
	<h2>Variable visibility</h2>
	<p>General solution:</p>
        <code>declare max="" line
while read -r line; do
    declare val="`parse "$line"`"
    if higher "$val" "$max"; then
        max="$val"
    fi
done <green>< <(get_values)</green>
</code>
</section>

<section>
	<h2>Variable visibility</h2>
	<p>Cleaner:</p>
        <code>print_max() {
    declare max="" line
    while read -r line; do
        update_max "$line"
    done
    echo "$max"
}

max="` get_values | print_max `"
</code>
</section>

<section>
	<h2>Variable contents</h2>
	<p>Arbitrary values: üôÇ</p>
        <code>print_max() {
    declare max="" line
    while read -r line; do
        update_max "$line"
    done
    <green>printf '%s\n'</green> "$max"
}

max="` get_values | print_max `"
</code>
</section>

<div id="progress-bar"></div>
