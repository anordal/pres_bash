<!DOCTYPE html>
<meta charset="utf-8">

<!-- dzslides core
    __  __  __       .  __   ___  __
   |  \  / /__` |    | |  \ |__  /__`
   |__/ /_ .__/ |___ | |__/ |___ .__/ core :‚Ç¨

The default files are not supposed to be edited. Not that you can't.
-->
<script src="default/slide.js"></script>
<link rel="stylesheet" href="default/style.css">

<!-- Maybe a font from http://www.google.com/webfonts ? -->
<link href='http://fonts.googleapis.com/css?family=Oswald' rel='stylesheet'>
<!-- Your Style -->
<link rel="stylesheet" href="custom.css">

<title>Bash best and worst practices</title>

<section>
	<h1>Bash</h1>
	<h2>best and worst practices</h2>
	<footer>by Philipp Martis and Andreas Nordal</footer>
</section>

<section>
	<h1>Why care</h1>
	<p class="next">Common myths:</p>
	<ul>
	<li><i>LOL, shellscripts are old-school</i></li>
	<li><i>I'm not writing them</i></li>
	<li><i>Leads to bugs</i></li>
	</ul>
</section>

<section>
	<h3>What <i>is</i> shellscripting anyway?</h3>
	<code>&gt;¬†1+1
1+1: Command not found.
&gt;¬†calc '1+1'
2</code>
	<p><ul>
		<li class="next">Programs as building blocks</li>
		<li class="next">Shellscripting is a paradigm!</li>
	</ul></p>
	<footer><i>‚ÄúOld school‚Äù</i></footer>
</section>

<section>
	<h3>Where shellscripts are found</h3>
	<ul>
		<li>Personal automation</li>
		<li>Your typical test script</li>
		<li>Build systems</li>
		<ul>
			<li>Makefiles</li>
			<li>Dockerfiles</li>
			<li>Openembedded</li>
		</ul>
		<li>Every script that runs over <tt>ssh</tt></li>
	</ul>
	<footer><i>‚ÄúI'm not writing them‚Äù</i></footer>
</section>

<section>
	<h3>How <em>not</em> to write a shellscript?</h3>
	<code>std::system("cmd");</code>
	<code class="next">std::system("cmd " <red>+</red> arg);</code>
	<code class="next">const char* cmd[] = {
    "cmd",
    arg,
    nullptr
};
<green>posix_spawn</green>(‚Ä¶, cmd[0], ‚Ä¶, ‚Ä¶, cmd, ‚Ä¶);</code>
</section>

<section>
	<h3>How <em>not</em> to write a shellscript?</h3>
	<ul>
		<li>You don't need the shell to run one command.</li>
		<ul>
			<li class="next">Args are an array: Best kept as such</li>
		</ul>
		<li class="next">Writing a shellscript at runtime is an unnecessary liability<br/>‚Üí string processing = bad<br/>‚Üí taking arguments = OK</li>
	</ul>
</section>

<section>
	<p class="next">#1 bug antidote ‚Üí</p>
	<footer><i>‚ÄúLeads to bugs‚Äù</i></footer>
</section>




<section>
	<h3>The driver's license of Bash scripting</h3>
	<h1><b>"</b>Quoting<b>"</b></h1>
</section>

<section>
	<h3>Must be quoted</h3>
	<h1><b>"</b>$var<b>"</b></h1>
	<footer>Variable expansion</footer>
</section>

<section>
	<h3>Must be quoted</h3>
	<h1><b>"</b>$(cmd)<b>"</b></h1>
	<h1 class="next"><b>"</b>`cmd`<b>"</b></h1>
	<footer>Command substitution</footer>
</section>

<section>
	<h1>Why quote?</h1>
	<p class="evil next">üî• Evil implicit behavior üî•</p>
	<ol>
	<li>Word splitting</li>
	<li>Filename expansion</li>
	</ol>
</section>

<section>
	<p>What happens here?</p>
	<code>file="Aqua - Doctor Jones.mp3"
rm $file</code>
	<code class="next">‚Üí <span class="bg">rm</span> <span class="bg">Aqua</span> <span class="bg">-</span> <span class="bg">Doctor</span> <span class="bg">Jones.mp3</span></code>
	<footer>Word splitting</footer>
</section>

<section>
	<p>What happens here?</p>
	<code>dir="Sagittarius_A*"
rm -rf $dir</code>
	<code class="next">‚Üí <span class="bg">rm</span> <span class="bg">-rf</span> <span class="bg">Sagittarius_AB</span> <span class="bg">Sagittarius_And_Other_Dwarf_Galaxies</span> <span class="bg">Sagittarius_A*</span></code>
	<footer>Filename expansion</footer>
</section>

<section>
	<h2>Quiz</h2>
	<code>file="; rm -rf /"
cat $file</code>
	<code class="next">‚Üí <span class="bg">cat</span> <span class="bg">;</span> <span class="bg">rm</span> <span class="bg">-rf</span> <span class="bg">/</span></code>
	<p class="next"><i>Not</i> a crazy macro language.</p>
	<footer>Just word splitting &amp; filename expansion</footer>
</section>

<section>
	<h3>The driver's license of Bash scripting</h3>
	<p>That's it!</p>
	<p>How to make it practical?</p>
	<h1>Demo</h1>
	<footer>shellcheck &amp; shellharden</footer>
</section>



<section>
	<h1>Good practices</h1>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Arrays</h3>
	<code>files=(
    "Aqua - Doctor Jones.mp3"
    **/*.{h,cpp}
)
for f in "${files[@]}"; do
    ‚Ä¶
done</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Input and output</h3>
	<ul>
		<li class="next"><tt>&></tt>: Redirect stdout and stderr at once
	</ul>
	<br>
	<ul>
		<li class="next"><tt><<-'EOF'</tt>: Redirect stdin to yield
			the upcoming lines, until <tt>EOF</tt>
		<ul>
			<li class="next">... ignoring leading tabs (<tt>-</tt>)
			<li class="next">... literally (<tt>''</tt>)
		</ul>
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Input and output</h3>
	<ul>
		<li class="next"><tt><<< asdf</tt>: Redirect stdin to yield
			<tt>asdf</tt>
	</ul>
	<br>
	<ul>
		<li class="next"><tt><(git show)</tt>: Usable like a file
			containing the output of <tt>git show</tt>
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Parameter expansion</h3>
	<ul>
		<li><tt>${s%%/*}</tt>: <tt>s</tt>,
			without trailing <tt>/*</tt>
		<li><tt>${s#*/}</tt>: <tt>s</tt>,
			without shortest leading <tt>*/</tt>
		<li><tt>${s/a/b}</tt>: <tt>s</tt>,
			replacing first <tt>a</tt> with <tt>b</tt>
		<li><tt>${s//a/b}</tt>: <tt>s</tt>,
			replacing every <tt>a</tt> with <tt>b</tt>
		<li><tt>${!s}</tt>: Content of variable named <tt>"$s"</tt>
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3><tt>shopt -s</tt></h3>
	<ul>
		<li><tt>dotglob</tt>: Include hidden files when globbing
		<li><tt>nullglob</tt>: Expand unmatching globs to empty array
		<li><tt>globstar</tt>: Expand double-stars (<tt>**</tt>) recursively
		<li><tt>nocasematch</tt>: Ignore case
			(<b>not in</b> <tt>test</tt>/<tt>[</tt>!)
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3><tt>set</tt></h3>
	<ul>
		<li><tt>-x</tt>: Echo executed commands
		<li><tt>-e</tt>: Exit on errors (covered later)
		<li><tt>-u</tt>: Treat unset variables as errors (and exit)
		<li><tt>-o pipefail</tt>: Pipe fails if <b>any</b> of its commands fail
	</ul>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Grouping: <tt>{ }</tt></h3>
	<code>cleanup || { essential_cleanup; exit 1; }</code>
	<code class="next">{ echo "[configuration]"; make_config; } > file.conf</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Subshells: <tt>( )</tt></h3>
	<medium>Changes don't affect parent shell</medium>
	<code class="next">( set -x; cmd lots of parameters )</code>
	<code class="next">if ( shopt -s nocasematch; [[ "$s" == "yes" ]] )</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Extended conditionals: <tt>[[¬†]]</tt></h3>
	<code class="next">shopt -s nocasematch; [[¬†"a" == "A" ]]</code>
	<code class="next">[[¬†"a" > "b" && (-f "file" || ! -f "file") ]]</code>
	<code class="next">[[ "a" =~ ^a(bc)*$ ]]</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Arithmetic conditionals: <tt>((¬†))</tt></h3>
	<code class="next">(( ! updated ))</code>
	<code class="next">(( (i += 2 ** $?) && (1 << 1 & 2) ))</code>
	<code class="next">for (( i = 0; i < n; ++i ))</code>
	<medium class="next">Be aware of recursive and history expansion!</medium>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Switch</h3>
	<code>case "$f" in
    *.h|*.cpp)
        ‚Ä¶
    ;;
    *)
        ‚Ä¶
    ;;
esac</code>
</section>

<section>
	<h2>Use what Bash provides!</h2>
	<h3>Exit handler</h3>
	<code>set -e
tmpdir="$(mktemp -d)"
cleanup() {
    rm -rf "$tmpdir"
}
trap cleanup EXIT

cd "$tmpdir"
‚Ä¶
‚Ä¶
‚Ä¶
echo 'Great success!'</code>
</section>

<section>
	<h2>set -e</h2>
	<p>Some object fiercly to it</p>
	<br>
	<ul>
		<li>They have <a href=https://wiki.bash-hackers.org/scripting/obsolete>good</a>
				<a href=http://mywiki.wooledge.org/BashFAQ/105>points</a>
		<li>There are also good points for it:
		<ul>
			<li class="next">Less code: more readable and less error-prone
			<li class="next">Catches most (programming) errors
		</ul>
	</ul>
</section>

<section>
	<h2>set -e</h2>
	<p>One example of the tribulations with <tt>set -e</tt></p>
	<code>f() {
    ( set -e; false; echo "D'oh!" )
}
f && false</code>
</section>

<section>
	<h2>set -e</h2>
	<small>
		The <tt>&&</tt> thwarts <tt>set -e</tt>,
		even inside a subshell inside a function!
	</small>
	<div class="next">
		<br>
		<p>Solution:</p>
		<code>f <green>& wait $!</green> && false</code>
	</div>
</section>





<section>
	<h1>Pitfalls</h1>
</section>


<section>
	<p>Positional args</p>
	<code>#!/bin/bash
echo "$1"</code>
	<code class="next">#!/bin/bash
echo "$10"</code>
	<code class="next">#!/bin/bash
echo "${10}"</code>
</section>

<section>
	<p>"$<b>{</b>10<b>}</b>" ‚Ä¶ But why?</p>
	<p class="next">There are 2 types of variable names:</p>
	<ol>
	<li class="next">An identifier: <code>[_a-zA-Z][_a-zA-Z0-9]*</code></li>
	<li class="next">A non-identifier single character: <code>[^_a-zA-Z]</code></li>
	</ol>
</section>

<section>
	<h2>Quiz</h2>
	<p>Where does the variable name end?</p>
	<code>einstein() { echo "$1ball"; }
einstein foot
</code>
	<code class="next">‚Üí <span class="bg">football</span>
‚Üí </code>
</section>

<section>
	<h2>Escaping and ` `</h2>
	<br>
	<br>
	<p class="next">Use <red>` `</red> only for simple things, if at all!</p>
</section>

<section>
	<h2>Quiz</h2>
	<p>How do you rewrite the following, using only one <tt>echo</tt>:</p>
	<code>echo "` echo "$(echo 'h\\i')" `"</code>
	<code class="next">echo 'h\i'  # or echo "h\\i"</code>
</section>

<section>
	<h2>Escaping and ` `</h2>
	<p>Being syntactically surrounded by <tt>` `</tt>
		is enough to halve the number of <tt>\\</tt>s.
	</p>
	<p class="next"><tt>\n</tt> stays <tt>\n</tt>.
	</p>
</section>

<section>
	<h2>Variable scope</h2>
	<p>Consider</p>
	<code>greet() {
    name="$1"
    for s in –ø—Ä–∏–≤–µ—Ç Hello Hei; do
        echo "$s, $name!"
    done
}

read -p "What's your name? " s
greet "$s"
echo "I like the name $s!"
</code>
</section>

<section>
	<h2>Variable scope</h2>
	<p>Correct:</p>
	<code>greet() {
    <green>declare</green> name="$1" <green>s</green>
    for s in –ø—Ä–∏–≤–µ—Ç Hello Hei; do
        echo "$s, $name!"
    done
}

read -p "What's your name? " s
greet "$s"
echo "I like the name $s!"
</code>
</section>

<section>
	<h2>Variable scope</h2>
	<p>Good: üôÇ</p>
	<code>greet() {
    declare name="$1" <green>hello</green>
    for <green>hello</green> in –ø—Ä–∏–≤–µ—Ç Hello Hei; do
        echo "<green>$hello</green>, $name!"
    done
}

<green>declare name</green>
read -p "What's your name? " <green>name</green>
greet <green>"$name"</green>
echo "I like the name <green>$name</green>!"
</code>
</section>

<section>
	<h2>Variable visibility</h2>
	<p>Consider</p>
	<code>declare max="" line
get_values | while read -r line; do
    declare val="`parse "$line"`"
    if higher "$val" "$max"; then
        max="$val"
    fi
done
</code>
</section>

<section>
	<h2>Variable visibility</h2>
	<br>
	<p><tt>max</tt> isn't changed, since the whole loop
		runs in a subshell introduced by <tt>|</tt>.
	</p>
</section>

<section>
	<h2>Variable visibility</h2>
	<p>General solution:</p>
	<code>declare max="" line
while read -r line; do
    declare val="`parse "$line"`"
    if higher "$val" "$max"; then
        max="$val"
    fi
done <green>< <(get_values)</green>
</code>
</section>

<section>
	<h2>Variable contents</h2>
	<p>Cleaner:</p>
	<code>print_max() {
    declare max="" line
    while read -r line; do
        update_max "$line"
    done
    echo "$max"
}

max="` get_values | print_max `"
</code>
</section>

<section>
	<h2>Variable contents</h2>
	<p>Arbitrary values: üôÇ</p>
	<code>print_max() {
    declare max="" line
    while <green>IFS=</green> read -r line; do
        update_max "$line"
    done
    <green>printf '%s\n'</green> "$max"
}

max="` get_values | print_max `"
</code>
</section>

<div id="progress-bar"></div>
